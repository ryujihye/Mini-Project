<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        body {
            height: 100vh;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            border: 4px solid navy;
        }

        .canvas-container {
            height: 100%;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>

<body>

    <div class="canvas-container">
        <canvas id="myCanvas" width="700" height="500"></canvas>
    </div>
    <script>
        const canvas = document.getElementById("myCanvas");
        const ctx = canvas.getContext("2d");
        const bar = canvas.getContext("2d");
        const brick = canvas.getContext("2d");

        let directionX = 1;
        let directionY = 1;
        let speed = 4;
        let ballSize = 12;
        const canvasWidth = 700;
        const canvasHeight = 500;

        let ballXPosition = 300;
        let ballYPosition = 180;

        let barXPosition = 1;
        let barYPosition = canvasHeight - 25;
        let barWidth = 100;
        let barHeight = 14;
        let barSpeed = 15;
        const leftWall = 1;

        // block Object
        let block = function (blockXPosition, blockYPosition, width, height, color) {
            this.height = height;
            this.width = width;
            this.blockXPosition = blockXPosition;
            this.blockYPosition = blockYPosition;
            this.color = color;


            this.draw = function () {
                // console.log("+_+");
                brick.beginPath();
                brick.rect(this.blockXPosition, this.blockYPosition, this.width, this.height);
                brick.fillStyle = this.color;
                brick.fill();
                brick.closePath();

            };

        };



        const blocks = [];

        let blockCount = 6;
        let moveBrick = 115;


        for (let i = 0; i < blockCount; i++) {
            let block1 = new block(12.5 + moveBrick * i, 15, 100, 20, "deepPink");
            blocks.push(block1)

        }

        console.log(blocks);
        // console.log(block1);




        setInterval(() => {

            // Bar process

            // key check
            if (keyState[37]) {

                // bar collision process
                // 충돌하지 않을때
                if (barXPosition >= leftWall) {

                    // Bar position
                    // 이동
                    barXPosition = barXPosition - barSpeed;
                }


            }


            if (keyState[39]) {

                if (barXPosition < canvasWidth - barWidth) {


                    barXPosition = barXPosition + barSpeed;
                }
            }

            // bar & ball collision process
            if (ballYPosition + ballSize >= barYPosition && (ballXPosition >= barXPosition && ballXPosition <=
                    barXPosition + barWidth)) {
                directionY = -directionY;
                console.log("boom!");
            }


            // reset drawing
            ctx.clearRect(0, 0, canvasWidth, canvasHeight)

            // draw process

            // draw a ball
            ctx.beginPath();
            ctx.arc(ballXPosition, ballYPosition, ballSize, 0, Math.PI * 2, false);
            ctx.fillStyle = "navy";
            ctx.fill();
            ctx.closePath();

            // draw a bar
            bar.rect(barXPosition, barYPosition, barWidth, barHeight);
            bar.fillStyle = "deepPink";
            bar.fill();
            bar.closePath();

      
            blocks.forEach((v,index)=> {
                // let index = 0;
                // rect1 ball x: ballXPosition
                // rect2 block y : blockXPosition

                // console.log(v);

                if (ballXPosition < v.blockXPosition + v.width &&
                    ballXPosition + ballSize > v.blockXPosition &&
                    ballYPosition < v.blockYPosition + v.height &&
                    ballYPosition + ballSize > v.blockYPosition) {
                    // collision detected!

                    console.log("충돌충돌 !!!");

                 
                    // 현재 충돌하는 v의 인덱스
                    console.log(index);
                 
                }


            });

            // draw block
            blocks.forEach(singleBlock => {
                singleBlock.draw()
            });


            // ball position
            ballXPosition = ballXPosition + directionX * speed;
            ballYPosition = ballYPosition + directionY * speed;

            // collision process
            if (canvasWidth - ballSize <= ballXPosition || ballXPosition < ballSize) directionX = -directionX;
            if (canvasHeight - ballSize <= ballYPosition || ballYPosition < ballSize) directionY = -directionY;


        }, 1000 / 60)

        const keyState = {

            37: false,
            39: false

        };
        // 이벤트리스너는 전역에서 한 번 만 달면 된다.
        // 루프에 포함시키지 않도록(루프에 넣게되면 이벤트가 계속 생성된다.)

        window.addEventListener("keydown", (event) => {
            const key = event.keyCode

            // 키를 눌렀을 때 
            if (key == 37) {
                keyState[37] = true;
            } else if (key == 39) {
                keyState[39] = true;
            }

            console.log(keyState);
        })

        window.addEventListener("keyup", (event) => {
            const key = event.keyCode

            // 키를 떼었을 때 
            if (key == 37) {
                keyState[37] = false;
            } else if (key == 39) {
                keyState[39] = false;
            }

            console.log(keyState);
        })
    </script>
</body>

</html>